<html>
  <head>
    <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin="" />
    <link
      rel="stylesheet"
      as="style"
      onload="this.rel='stylesheet'"
      href="https://fonts.googleapis.com/css2?display=swap&amp;family=Inter%3Awght%40400%3B500%3B700%3B900&amp;family=Noto+Sans%3Awght%40400%3B500%3B700%3B900"
    />
    <title>Appointment Details - Zetteri</title>
    <link rel="icon" type="image/x-icon" href="zetteri-favicon.png" />
    <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
    <style>
      /* Estilo para asegurar que el body del iframe ocupe el espacio */
      body, html {
        height: 100%;
        margin: 0;
        padding: 0;
        background-color: transparent; /* Para que tome el fondo del modal si es necesario */
      }
      /* Ajustes para Tailwind Forms en dark mode si es necesario */
      .dark .form-input, .dark .form-textarea, .dark .form-select, .dark .form-checkbox, .dark .form-radio {
        background-color: #374151; /* gray-700 */
        border-color: #4b5563; /* gray-600 */
        color: #f3f4f6; /* gray-100 */
      }
      .dark .form-input:focus, .dark .form-textarea:focus, .dark .form-select:focus {
        border-color: #3b82f6; /* blue-500 */
        box-shadow: 0 0 0 1px #3b82f6;
      }
    </style>
  </head>
  <body class="bg-white text-slate-900 p-6 sm:p-8">
    <div class="max-w-2xl mx-auto">
      <h2 id="form-title" class="text-2xl font-bold mb-6">Appointment Details</h2>

      <form id="appointment-form" class="space-y-6">
        <div>
          <label for="title" class="block text-sm font-medium">Title <span class="text-red-500">*</span></label>
          <input type="text" name="title" id="title" required class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm dark:bg-slate-200 dark:border-slate-600 dark:placeholder-slate-400">
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div>
            <label for="startTimeDate" class="block text-sm font-medium">Start Date <span class="text-red-500">*</span></label>
            <input type="date" name="startTimeDate" id="startTimeDate" required class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm dark:bg-slate-200 dark:border-slate-600">
          </div>
          <div>
            <label for="startTimeTime" class="block text-sm font-medium">Start Time <span class="text-red-500">*</span></label>
            <input type="time" name="startTimeTime" id="startTimeTime" required class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm dark:bg-slate-200 dark:border-slate-600">
          </div>
        </div>

        <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
          <div>
            <label for="endTimeDate" class="block text-sm font-medium">End Date</label>
            <input type="date" name="endTimeDate" id="endTimeDate" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm dark:bg-slate-200 dark:border-slate-300">
          </div>
          <div>
            <label for="endTimeTime" class="block text-sm font-medium">End Time</label>
            <input type="time" name="endTimeTime" id="endTimeTime" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm dark:bg-slate-200 dark:border-slate-300">
          </div>
        </div>
        
        <div>
          <label for="clientName" class="block text-sm font-medium">Client Name</label>
          <input type="text" name="clientName" id="clientName" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm dark:bg-slate-200 dark:border-slate-300 dark:placeholder-slate-400">
        </div>

        <div>
          <label for="clientEmail" class="block text-sm font-medium">Client Email</label>
          <input type="email" name="clientEmail" id="clientEmail" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm dark:bg-slate-200 dark:border-slate-300 dark:placeholder-slate-400">
        </div>
        
        <div>
          <label for="serviceDescription" class="block text-sm font-medium">Service Description</label>
          <textarea id="serviceDescription" name="serviceDescription" rows="3" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm dark:bg-slate-200 dark:border-slate-300 dark:placeholder-slate-400"></textarea>
        </div>

        <div>
          <label for="notes" class="block text-sm font-medium">Notes</label>
          <textarea id="notes" name="notes" rows="3" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm dark:bg-slate-200 dark:border-slate-300 dark:placeholder-slate-400"></textarea>
        </div>

        <div>
          <label for="status" class="block text-sm font-medium">Status</label>
          <select id="status" name="status" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm dark:bg-slate-400 dark:border-slate-600">
            <option value="scheduled">Scheduled</option>
            <option value="confirmed">Confirmed</option>
            <option value="completed">Completed</option>
            <option value="cancelled">Cancelled</option>
          </select>
        </div>

        <div class="flex flex-wrap gap-3 pt-4 pb-5">
          <button type="submit" id="save-appointment-btn" class="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white font-semibold rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500">
            Save Appointment
          </button>
          <button type="button" id="cancel-btn" class="px-4 py-2 bg-gray-200 hover:bg-gray-300 text-gray-700 font-semibold rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-gray-400 dark:bg-slate-600 dark:hover:bg-slate-500 dark:text-slate-200">
            Cancel
          </button>
          <button type="button" id="delete-appointment-btn" class="px-4 py-2 bg-red-600 hover:bg-red-700 text-white font-semibold rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 hidden">
            Delete Appointment
          </button>
        </div>
      </form>
    </div>

    <script type="module">
      import { initializeApp } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-app.js";
      import { getAuth } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-auth.js";
      import { getFirestore, doc, getDoc, addDoc, updateDoc, deleteDoc, collection, Timestamp, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.8.1/firebase-firestore.js";

      const firebaseConfig = {
          apiKey: "AIzaSyBppyJBT_uWC2hIJU-qnMZCNlac5uVTRmM",
          authDomain: "zetter-app.firebaseapp.com",
          projectId: "zetter-app",
          storageBucket: "zetter-app.appspot.com",
          messagingSenderId: "386722095231",
          appId: "1:386722095231:web:f5abe66895fea3746bdf4a",
          measurementId: "G-D7E0PDYDN5"
      };

      const app = initializeApp(firebaseConfig);
      const auth = getAuth(app);
      const db = getFirestore(app);

      const appointmentForm = document.getElementById('appointment-form');
      const formTitleEl = document.getElementById('form-title');
      const saveButton = document.getElementById('save-appointment-btn');
      const cancelButton = document.getElementById('cancel-btn');
      const deleteButton = document.getElementById('delete-appointment-btn');
      
      // Input fields
      const titleInput = document.getElementById('title');
      const startTimeDateInput = document.getElementById('startTimeDate');
      const startTimeTimeInput = document.getElementById('startTimeTime');
      const endTimeDateInput = document.getElementById('endTimeDate');
      const endTimeTimeInput = document.getElementById('endTimeTime');
      const clientNameInput = document.getElementById('clientName');
      const clientEmailInput = document.getElementById('clientEmail');
      const serviceDescriptionInput = document.getElementById('serviceDescription');
      const notesInput = document.getElementById('notes');
      const statusInput = document.getElementById('status');

      let currentMode = 'new'; // 'new' or 'edit'
      let appointmentId = null;
      let professionalUserId = null; // Will be set on auth state change
      
      let originalCompleted = null;   // <-- Añade esto
      let originalConfirmed = null;   // <-- Y esto

      // Helper to convert Date and Time inputs to Firestore Timestamp
      function getTimestampFromDateTime(dateStr, timeStr) {
          if (!dateStr || !timeStr) return null;
          const [year, month, day] = dateStr.split('-').map(Number);
          const [hours, minutes] = timeStr.split(':').map(Number);
          return Timestamp.fromDate(new Date(year, month - 1, day, hours, minutes));
      }

      // Helper to set Date and Time inputs from Firestore Timestamp
      function setDateTimeInputsFromTimestamp(timestamp, dateInput, timeInput) {
          if (timestamp && timestamp.toDate) {
              const dateObj = timestamp.toDate();
              dateInput.value = dateObj.toISOString().split('T')[0];
              timeInput.value = dateObj.toTimeString().split(' ')[0].substring(0,5); // HH:MM
          } else {
              dateInput.value = '';
              timeInput.value = '';
          }
      }

      document.addEventListener('DOMContentLoaded', () => {
        const urlParams = new URLSearchParams(window.location.search);
        currentMode = urlParams.get('mode') || 'new';
        appointmentId = urlParams.get('id');
        const selectedDateParam = urlParams.get('date');

        auth.onAuthStateChanged(async user => {
          if (user) {
            professionalUserId = user.uid;
            console.log("=== AUTH DEBUG ===");
            console.log("user.uid:", user.uid);
            console.log("professionalUserId:", professionalUserId);
            console.log("=== END AUTH DEBUG ===");
            if (currentMode === 'edit' && appointmentId) {
              formTitleEl.textContent = 'Edit Appointment';
              saveButton.textContent = 'Update Appointment';
              deleteButton.classList.remove('hidden');
              await loadAppointmentData(appointmentId);
            } else {
              formTitleEl.textContent = 'New Appointment';
              saveButton.textContent = 'Create Appointment';
              deleteButton.classList.add('hidden');
              if (selectedDateParam) {
                startTimeDateInput.value = selectedDateParam;
                // Podrías pre-rellenar una hora por defecto si quieres, ej: 09:00
                startTimeTimeInput.value = "09:00"; 
              }
            }
          } else {
            // No debería ocurrir si el iframe se carga desde una página autenticada
            console.error("User not authenticated in appt-details.");
            // Podrías enviar un mensaje para cerrar o mostrar un error
            window.parent.postMessage({ action: 'closeModal', error: 'Authentication lost' }, '*');
          }
        });
      });

      async function loadAppointmentData(id) {
        if (!professionalUserId) {
            console.error("Cannot load appointment data, professionalUserId is not set.");
            return;
        }
        try {
          const apptRef = doc(db, 'appointments', id);
          const apptSnap = await getDoc(apptRef);

          if (apptSnap.exists()) {
            const data = apptSnap.data();
            // Security check: ensure the professionalId matches the current user
            if (data.professionalId !== professionalUserId) {
                console.error("Security Alert: Attempted to load appointment not belonging to the current user.");
                alert("You do not have permission to edit this appointment.");
                window.parent.postMessage({ action: 'closeModal' }, '*');
                return;
            }

            originalCompleted = typeof data.completed === "boolean" ? data.completed : null;
            originalConfirmed = typeof data.confirmed === "boolean" ? data.confirmed : null;

            titleInput.value = data.title || '';
            setDateTimeInputsFromTimestamp(data.startTime, startTimeDateInput, startTimeTimeInput);
            setDateTimeInputsFromTimestamp(data.endTime, endTimeDateInput, endTimeTimeInput);
            clientNameInput.value = data.clientName || '';
            clientEmailInput.value = data.clientEmail || '';
            serviceDescriptionInput.value = data.serviceDescription || '';
            notesInput.value = data.notes || '';
            statusInput.value = data.status || 'scheduled';
          } else {
            console.error('No such appointment found!');
            alert('Appointment not found. It may have been deleted.');
            window.parent.postMessage({ action: 'closeModal' }, '*');
          }
        } catch (error) {
          console.error('Error loading appointment:', error);
          alert('Error loading appointment details.');
        }
      }

      appointmentForm.addEventListener('submit', async (e) => {
        e.preventDefault(); 

        if (!professionalUserId) {
            alert("Error: User information is not available. Please sign out and sign in again.");
            return;
        }

        const titleValue = titleInput.value.trim();
        if (!titleValue) {
            alert("Title is required.");
            titleInput.focus();
            return;
        }

        const startTimeValue = getTimestampFromDateTime(startTimeDateInput.value, startTimeTimeInput.value);
        if (!startTimeValue) {
            alert("Start date and time are required.");
            startTimeDateInput.focus();
            return;
        }

        const endTimeValue = getTimestampFromDateTime(endTimeDateInput.value, endTimeTimeInput.value);
        if (endTimeValue && endTimeValue <= startTimeValue) {
            alert("End time must be after start time.");
            endTimeDateInput.focus();
            return;
        }

        // Construir el objeto base con todos los campos posibles
        const appointmentDataPayload = {
          professionalId: professionalUserId,
          title: titleValue,
          startTime: startTimeValue,
          endTime: endTimeValue, // Será null si no se proporcionó fecha/hora de fin
          clientName: clientNameInput.value.trim() || null,
          clientEmail: clientEmailInput.value.trim() || null,
          serviceDescription: serviceDescriptionInput.value.trim() || null,
          notes: notesInput.value.trim() || null,
          status: statusInput.value,
        };

        // Añadir campos 'completed' y 'confirmed' solo si son booleanos
        if (typeof originalCompleted === "boolean") {
          appointmentDataPayload.completed = originalCompleted;
        }
        if (typeof originalConfirmed === "boolean") {
          appointmentDataPayload.confirmed = originalConfirmed;
        }
        
        try {
          saveButton.disabled = true;
          
          if (currentMode === 'new') {
            saveButton.textContent = 'Creating...';
            let dataForCreate = { // Usamos let para poder modificarlo (eliminar nulls)
                ...appointmentDataPayload,
                createdAt: serverTimestamp() 
            };
            // No debería haber 'updatedAt' en la creación inicial
            delete dataForCreate.updatedAt; 

            // Elimina campos con valores null antes de enviar la solicitud DE CREACIÓN
            Object.keys(dataForCreate).forEach(key => {
              if (dataForCreate[key] === null) {
                delete dataForCreate[key];
              }
            });

            console.log("--- DEBUG CREATE ---");
            console.log("Data being sent for CREATE:", JSON.stringify(dataForCreate, null, 2));
            console.log("--- END DEBUG CREATE ---");

            await addDoc(collection(db, 'appointments'), dataForCreate);
            alert('Appointment created successfully!');
          } else { // currentMode === 'edit'
            saveButton.textContent = 'Updating...';
            let dataForUpdate = { // Usamos let para poder modificarlo (eliminar nulls)
                ...appointmentDataPayload,
                updatedAt: serverTimestamp() // <--- ¡ESTA ES LA CORRECCIÓN CRUCIAL!
            };
            // Asegurarse de no enviar createdAt en una actualización
            delete dataForUpdate.createdAt;

            // Verifica que solo se envíen las claves permitidas
            const allowedKeys = ['professionalId', 'title', 'startTime', 'endTime', 'clientName', 'clientEmail', 'serviceDescription', 'notes', 'status', 'completed', 'confirmed', 'updatedAt'];
            Object.keys(dataForUpdate).forEach(key => {
              if (!allowedKeys.includes(key)) {
                delete dataForUpdate[key];
              }
            });

            console.log("--- DEBUG UPDATE ---");
            console.log("Appointment ID:", appointmentId);
            console.log("Professional User ID (from JS):", professionalUserId);
            console.log("Data being sent for UPDATE:", JSON.stringify(dataForUpdate, null, 2));
            console.log("Keys in dataForUpdate:", Object.keys(dataForUpdate));
            console.log("--- END DEBUG UPDATE ---");

            const apptRef = doc(db, 'appointments', appointmentId);
            await updateDoc(apptRef, dataForUpdate);
            alert('Appointment updated successfully!');
          }
          window.parent.postMessage({ action: 'appointmentSaved' }, '*');
        } catch (error) {
          console.error(`Error saving appointment (${currentMode}):`, error); 
          alert(`Error saving appointment: ${error.message}`); 
        } finally {
            saveButton.disabled = false;
            saveButton.textContent = currentMode === 'new' ? 'Create Appointment' : 'Update Appointment';
        }
      });

      cancelButton.addEventListener('click', () => {
        window.parent.postMessage({ action: 'closeModal' }, '*');
      });

      deleteButton.addEventListener('click', async () => {
        if (!appointmentId) return;
        if (confirm('Are you sure you want to delete this appointment?')) {
          try {
            deleteButton.disabled = true;
            deleteButton.textContent = 'Deleting...';
            const apptRef = doc(db, 'appointments', appointmentId);
            await deleteDoc(apptRef);
            alert('Appointment deleted successfully!');
            window.parent.postMessage({ action: 'appointmentSaved' }, '*'); 
          } catch (error) {
            console.error('Error deleting appointment:', error);
            alert(`Error deleting appointment: ${error.message}`);
          } finally {
            deleteButton.disabled = false;
            deleteButton.textContent = 'Delete Appointment';
          }
        }
      });
    </script>
  </body>
</html>